# Table of content
1. [Info](#Info)
2. [Useful_Stuffs](#Useful_Stuffs)
3. [Input-Redirection](#Input-Redirection)

---

# Info
Bourne again shell (bash)

Youtube
- [Bash in 100 Seconds](https://www.youtube.com/watch?v=I4EWvMFj37g)
- [Beginner's Guide to the Bash Terminal](https://www.youtube.com/watch?v=oxuRxtrO2Ag)

---

# Useful_Stuffs

## Arguments
- `!!` : grab previous command, useful for adding `sudo !!`
- `!$` : grab previous command args
- `!:3` : grab third argument
	- `!:1-2`

## Misc
- `echo $0` : shows shell running
- `grep -v -E '/proc | /sys'` : exclude /proc or /sys from output

## Pipeline
When you use the pipe (`|`), the shell redirects the **stdout** (standard output, file descriptor `1`) of the command on the left of the pipe to the **stdin** (standard input, file descriptor `0`) of the command on the right.

`command1 | command2`
```bash
cat file.txt | grep "search_string"
```

## Tee
You can use the `tee` command to send **stderr** and **stdout** to a file and then still continue a pipeline.

This creates a *file_list.txt* and then continues
```bash
ls -l | tee files_list.txt | wc -l
```


---

# Input-Redirection

In the context of input/output redirection in Unix-like systems (such as Linux), file descriptors (FDs) are used to represent input and output streams for processes. The most commonly used file descriptors are:

- **0**: **stdin** (standard input) — This is the default input stream, where data is typically received (like from a keyboard or a file).
- **1**: **stdout** (standard output) — This is the default output stream, where data is typically sent (like to a terminal or a file).
- **2**: **stderr** (standard error) — This is where error messages and diagnostics are sent.

### Understanding `0`, `1`, and `2` in Redirection

In redirection commands, the numbers `0`, `1`, and `2` refer to these file descriptors. You can redirect their input and output streams using operators like `>`, `>&`, `2>`, `2>&1`, etc.

### Redirection Examples:

1. **`0`: Redirecting `stdin`**
    
    - `command < file` — Redirects the contents of `file` to the command's `stdin`.
        
        - Example: `cat < input.txt` — The file `input.txt` is used as input to the `cat` command.
    - `command 0< file` — This explicitly indicates that the input redirection (`<`) is targeting file descriptor 0 (`stdin`).
        
2. **`1`: Redirecting `stdout`**
    
    - `command > file` — Redirects `stdout` to a file. If the file exists, it is overwritten; if it doesn't, it is created.
        
        - Example: `echo "Hello" > output.txt` — The string `"Hello"` is written to `output.txt`.
    - `command 1> file` — This is a more explicit version, which means the same as `>`. It tells the shell to send `stdout` (file descriptor 1) to `file`.
        
3. **`2`: Redirecting `stderr`**
    
    - `command 2> file` — Redirects `stderr` to a file, capturing errors.
        - Example: `ls non_existent_file 2> errors.txt` — The error message generated by trying to list a nonexistent file is written to `errors.txt`.
4. **Combining `stdout` and `stderr`: `2>&1`**
    
    - `command > file 2>&1` — This redirects both `stdout` and `stderr` to the same output location (the same file or stream).
        
        - `2>&1` means "redirect `stderr` (2) to wherever `stdout` (1) is currently going." This is often used when you want to capture both normal output and error messages in the same file or stream.
        
        Example:
        
        sh
        
        Copy code
        
        `command > output.txt 2>&1`
        
        This command redirects both the standard output and the standard error to `output.txt`.
        

### Example: Understanding `0>&1`, `2>&1`, etc.

Let’s break down common redirection patterns involving file descriptors:

- **`0<&1`**: This redirects the input stream (`stdin`, 0) from wherever `stdout` (1) is currently pointing. It’s less common, but useful if you want a command to receive input from what is normally an output stream.
    
- **`2>&1`**: This redirects `stderr` (2) to the same place as `stdout` (1). It effectively combines both error messages and normal output into the same destination (either a file or the terminal).
    
- **`1>&2`**: This redirects `stdout` (1) to `stderr` (2), sending normal output to the same place as errors are sent. It's less common but can be useful if you want to distinguish between different types of output and error messages.
    

### Real-World Use Case Example:

bash

Copy code

`ls non_existent_file > output.txt 2>&1`

- `ls non_existent_file`: This attempts to list a non-existent file and will produce an error message.
- `> output.txt`: Redirects `stdout` to `output.txt`.
- `2>&1`: Redirects `stderr` to the same place as `stdout`, meaning any error messages will also be written to `output.txt`.

In summary:

- `0`: Refers to `stdin` (input stream).
- `1`: Refers to `stdout` (normal output stream).
- `2`: Refers to `stderr` (error output stream).